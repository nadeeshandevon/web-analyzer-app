
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">web-analyzer-api/app/cmd/main.go (50.0%)</option>
				
				<option value="file1">web-analyzer-api/app/internal/api/middleware/auth.go (100.0%)</option>
				
				<option value="file2">web-analyzer-api/app/internal/api/middleware/cors.go (100.0%)</option>
				
				<option value="file3">web-analyzer-api/app/internal/api/middleware/error.go (100.0%)</option>
				
				<option value="file4">web-analyzer-api/app/internal/api/middleware/prometheus.go (100.0%)</option>
				
				<option value="file5">web-analyzer-api/app/internal/api/router.go (100.0%)</option>
				
				<option value="file6">web-analyzer-api/app/internal/api/v1/webanalyzer.go (81.2%)</option>
				
				<option value="file7">web-analyzer-api/app/internal/core/apperror/app_error.go (100.0%)</option>
				
				<option value="file8">web-analyzer-api/app/internal/core/web_analyzer/web_analyze_service.go (38.1%)</option>
				
				<option value="file9">web-analyzer-api/app/internal/core/web_analyzer/web_analyze_worker.go (85.4%)</option>
				
				<option value="file10">web-analyzer-api/app/internal/di/container.go (100.0%)</option>
				
				<option value="file11">web-analyzer-api/app/internal/repositorysql/web_analyzer_repo.go (100.0%)</option>
				
				<option value="file12">web-analyzer-api/app/internal/util/handler-utils.go (100.0%)</option>
				
				<option value="file13">web-analyzer-api/app/internal/util/html/html_helper.go (95.8%)</option>
				
				<option value="file14">web-analyzer-api/app/internal/util/logger/logger.go (100.0%)</option>
				
				<option value="file15">web-analyzer-api/app/internal/util/metrics/web_analyzer_http_metrics.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "time"

        "web-analyzer-api/app/internal/api"
        "web-analyzer-api/app/internal/di"
        "web-analyzer-api/app/internal/util/logger"

        "github.com/gin-contrib/pprof"
        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() <span class="cov0" title="0">{
        ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
        defer cancel()

        // Setup logger, HTTP and Metrics servers
        log, mainServer, metricsServer := setupServers()

        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                log.Info("HTTP server started", "address", mainServer.Addr)
                if err := mainServer.ListenAndServe(); !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Error("HTTP server failed unexpectedly", "error", err)
                }</span>
        }()

        // Start Metrics server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info("Metrics server started", "address", metricsServer.Addr)
                if err := metricsServer.ListenAndServe(); !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Error("Metrics server failed unexpectedly", "error", err)
                }</span>
        }()

        // Wait for shutdown signal
        <span class="cov0" title="0">&lt;-ctx.Done()
        log.Info("Shutdown signal received, initiating graceful shutdown")

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Shutdown servers
        var errs []error
        if err := mainServer.Shutdown(ctxTimeout); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to shutdown main server gracefully", "error", err)
                errs = append(errs, err)
        }</span>

        <span class="cov0" title="0">if err := metricsServer.Shutdown(ctxTimeout); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to shutdown metrics server gracefully", "error", err)
                errs = append(errs, err)
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                log.Error("Shutdown completed with errors")
        }</span> else<span class="cov0" title="0"> {
                log.Info("All servers shutdown completed successfully")
        }</span>
}

func setupServers() (*logger.Logger, *http.Server, *http.Server) <span class="cov8" title="1">{
        log := logger.Get(os.Getenv("LOG_LEVEL"))
        log.Info("Starting Web Analyzer application")

        app := di.NewContainer(log)
        log.Info("Dependency injection container initialized")

        router := gin.New()

        err := api.SetupRouter(router, app.HTTPHandlers, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to setup router", "error", err)
        }</span>
        <span class="cov8" title="1">log.Info("Router configuration completed")

        serverPort := os.Getenv("SERVER_PORT")
        if serverPort == "" </span><span class="cov8" title="1">{
                serverPort = "8081"
        }</span>

        <span class="cov8" title="1">metricsPort := os.Getenv("METRICS_PORT")
        if metricsPort == "" </span><span class="cov8" title="1">{
                metricsPort = "9090"
        }</span>

        <span class="cov8" title="1">enablePprof := os.Getenv("ENABLE_PPROF") == "true"

        log.Info("Starting HTTP server", "port", serverPort)
        httpServer := &amp;http.Server{
                Addr:    fmt.Sprintf(":%s", serverPort),
                Handler: router,
        }

        log.Info("Starting Metrics server", "port", metricsPort)
        metricsRouter := gin.New()
        metricsRouter.Use(gin.Recovery())
        metricsRouter.GET("/metrics", gin.WrapH(promhttp.Handler()))

        if enablePprof </span><span class="cov8" title="1">{
                log.Info("Enabling pprof on metrics server")
                pprof.Register(metricsRouter)
        }</span>

        <span class="cov8" title="1">metricsServer := &amp;http.Server{
                Addr:    fmt.Sprintf(":%s", metricsPort),
                Handler: metricsRouter,
        }

        return log, httpServer, metricsServer</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package middleware

import (
        "os"
        "web-analyzer-api/app/internal/core/apperror"
        "web-analyzer-api/app/internal/util"
        "web-analyzer-api/app/internal/util/logger"

        "github.com/gin-gonic/gin"
)

const (
        ApiKeyHeader     = "x-api-key"
        DefaultApiKey    = "dev-key-123"
        ApiKeyEnvVarName = "API_KEY"
)

func AuthMiddleware(log *logger.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        apiKey := os.Getenv(ApiKeyEnvVarName)
        if apiKey == "" </span><span class="cov8" title="1">{
                apiKey = DefaultApiKey
        }</span>

        <span class="cov8" title="1">return func(c *gin.Context) </span><span class="cov8" title="1">{
                requestKey := c.GetHeader(ApiKeyHeader)

                if requestKey == "" </span><span class="cov8" title="1">{
                        util.SetRequestError(c, apperror.Unauthorized("Missing API key in header"), log)
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">if requestKey != apiKey </span><span class="cov8" title="1">{
                        util.SetRequestError(c, apperror.Unauthorized("Invalid API key"), log)
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
)

func CORSMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT")

                if c.Request.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "net/http"
        "web-analyzer-api/app/internal/core/apperror"
        "web-analyzer-api/app/internal/util/logger"

        "github.com/gin-gonic/gin"
)

func ErrorHandler(logger logger.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Next()

                if len(c.Errors) &gt; 0 </span><span class="cov8" title="1">{
                        err := c.Errors.Last().Err
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Error("Error in request", "error", err)

                                switch e := err.(type) </span>{
                                case *apperror.AppError:<span class="cov8" title="1">
                                        if !c.Writer.Written() </span><span class="cov8" title="1">{
                                                c.JSON(e.StatusCode, gin.H{"status_code": e.StatusCode, "message": e.Message, "category": e.Category, "reason": e.Reason})
                                        }</span>
                                default:<span class="cov8" title="1">
                                        if !c.Writer.Written() </span><span class="cov8" title="1">{
                                                c.JSON(http.StatusInternalServerError, gin.H{"status_code": http.StatusInternalServerError,
                                                        "message": "Internal server error", "category": "Internal", "reason": "Internal"})
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "strconv"
        "time"
        "web-analyzer-api/app/internal/util/metrics"

        "github.com/gin-gonic/gin"
)

func init() <span class="cov8" title="1">{
        metrics.RegisterAPIMetrics()
}</span>

func PrometheusMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()
                path := c.FullPath()

                c.Next()

                if path == "/metrics" || path == "/health" </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">duration := time.Since(start).Seconds()
                status := strconv.Itoa(c.Writer.Status())
                method := c.Request.Method

                if path == "" </span><span class="cov8" title="1">{
                        path = "unknown"
                }</span>

                <span class="cov8" title="1">metrics.RecordHttpRequestTotal(method, path, status)
                metrics.RecordHttpRequestDuration(method, path, duration)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "web-analyzer-api/app/internal/api/middleware"
        "web-analyzer-api/app/internal/di"
        "web-analyzer-api/app/internal/util/logger"

        "github.com/gin-gonic/gin"
)

func SetupRouter(router *gin.Engine, handlers di.HTTPHandlers, logger *logger.Logger) error <span class="cov8" title="1">{
        router.Use(middleware.CORSMiddleware())
        router.Use(middleware.ErrorHandler(*logger))
        router.Use(middleware.PrometheusMiddleware())
        router.Use(gin.Recovery())

        v1 := router.Group("/api/v1")
        v1.Use(middleware.AuthMiddleware(logger))
        handlers.WebAnalyzerHandler.RegisterRoutes(v1)

        logger.Info("Router setup completed successfully")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package v1

import (
        "encoding/json"
        "net/http"
        "net/url"
        "web-analyzer-api/app/internal/contract"
        "web-analyzer-api/app/internal/core"
        "web-analyzer-api/app/internal/core/apperror"
        "web-analyzer-api/app/internal/util"
        "web-analyzer-api/app/internal/util/logger"

        "github.com/gin-gonic/gin"
)

type WebAnalyzerHandler struct {
        log                *logger.Logger
        webAnalyzerService core.WebAnalyzerService
}

func NewWebAnalyzerHandler(logger *logger.Logger, webAnalyzerService core.WebAnalyzerService) *WebAnalyzerHandler <span class="cov8" title="1">{
        return &amp;WebAnalyzerHandler{
                log:                logger,
                webAnalyzerService: webAnalyzerService,
        }
}</span>

func (h WebAnalyzerHandler) RegisterRoutes(v1 *gin.RouterGroup) <span class="cov0" title="0">{

        v1.POST("/web-analyzer/analyze",
                h.analyzeWebsite)

        v1.GET("/web-analyzer/:analyze_id/analyze",
                h.getAnalyzeData)
}</span>

func (h WebAnalyzerHandler) analyzeWebsite(c *gin.Context) <span class="cov8" title="1">{
        var req contract.WebAnalyzeRequest
        parsedURL, ok := h.validateRequest(c, &amp;req)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">result, err := h.webAnalyzerService.AnalyzeWebsite(c.Request.Context(), parsedURL)

        if err != nil </span><span class="cov8" title="1">{
                util.SetRequestError(c, err, h.log)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"analyze_id": result})</span>
}

func (h WebAnalyzerHandler) getAnalyzeData(c *gin.Context) <span class="cov8" title="1">{
        analyzeId := c.Param("analyze_id")
        if analyzeId == "" </span><span class="cov0" title="0">{
                util.SetRequestError(c, apperror.BadRequest("Analyze id cannot be empty"), h.log)
                return
        }</span>

        <span class="cov8" title="1">result, err := h.webAnalyzerService.GetAnalyzeData(c.Request.Context(), analyzeId)

        if err != nil </span><span class="cov8" title="1">{
                util.SetRequestError(c, err, h.log)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (h *WebAnalyzerHandler) validateRequest(c *gin.Context, req *contract.WebAnalyzeRequest) (*url.URL, bool) <span class="cov8" title="1">{
        if err := json.NewDecoder(c.Request.Body).Decode(req); err != nil </span><span class="cov8" title="1">{
                util.SetRequestError(c, apperror.BadRequest("Invalid request body: "+err.Error()), h.log)
                return nil, false
        }</span>

        // Validate URL format
        <span class="cov8" title="1">parsedURL, err := url.Parse(req.URL)
        if err != nil </span><span class="cov0" title="0">{
                util.SetRequestError(c, apperror.BadRequest("Invalid URL format: "+err.Error()), h.log)
                return nil, false
        }</span>
        <span class="cov8" title="1">if parsedURL.Scheme == "" || parsedURL.Host == "" </span><span class="cov8" title="1">{
                util.SetRequestError(c, apperror.BadRequest("Invalid URL format. Please provide a valid URL with scheme (http:// or https://)"), h.log)
                return nil, false
        }</span>
        <span class="cov8" title="1">return parsedURL, true</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package apperror

import (
        "fmt"
        "net/http"
)

const (
        CategoryValidation = "validation"
        CategoryAuth       = "auth"
        CategoryNotFound   = "not_found"
        CategoryInternal   = "internal"
        CategoryDownstream = "downstream"
        CategoryUnknown    = "unknown"
)

type AppError struct {
        StatusCode   int
        Message      string
        ChainedError error
        Category     string
        Reason       string
}

func BadRequest(message string) *AppError <span class="cov8" title="1">{
        return categorizedError(message, http.StatusBadRequest, CategoryValidation)
}</span>

func InternalServerError(message string) *AppError <span class="cov8" title="1">{
        return categorizedError(message, http.StatusInternalServerError, CategoryInternal)
}</span>

func Unauthorized(message string) *AppError <span class="cov8" title="1">{
        return categorizedError(message, http.StatusUnauthorized, CategoryAuth)
}</span>

func NotFound(message string) *AppError <span class="cov8" title="1">{
        return categorizedError(message, http.StatusNotFound, CategoryNotFound)
}</span>

func (e *AppError) Error() string <span class="cov8" title="1">{
        result := fmt.Sprintf("status code: %d, message: %s", e.StatusCode, e.Message)
        if e.ChainedError != nil </span><span class="cov8" title="1">{
                result += fmt.Sprintf("\nchained error: %s", e.ChainedError.Error())
        }</span>
        <span class="cov8" title="1">return result</span>
}

func categorizedError(message string, status int, category string) *AppError <span class="cov8" title="1">{
        return &amp;AppError{StatusCode: status, Message: message, Category: category}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package webanalyzer

import (
        "context"
        "net/http"
        "net/url"
        "strconv"
        "sync"
        "web-analyzer-api/app/internal/contract"
        "web-analyzer-api/app/internal/core"
        "web-analyzer-api/app/internal/core/apperror"
        "web-analyzer-api/app/internal/model"
        "web-analyzer-api/app/internal/repository"
        htmlhelper "web-analyzer-api/app/internal/util/html"
        "web-analyzer-api/app/internal/util/logger"

        "golang.org/x/net/html"
)

const (
        StatusPending = "pending"
        StatusSuccess = "success"
        StatusFailed  = "failed"
)

type webAnalyzerService struct {
        log         *logger.Logger
        repo        repository.WebAnalyzerRepository
        linkChecker core.LinkChecker
}

func NewWebAnalyzerService(logger *logger.Logger, repo repository.WebAnalyzerRepository, linkChecker core.LinkChecker) core.WebAnalyzerService <span class="cov8" title="1">{
        return &amp;webAnalyzerService{
                log:         logger,
                repo:        repo,
                linkChecker: linkChecker,
        }
}</span>

func (s *webAnalyzerService) AnalyzeWebsite(ctx context.Context, baseURL *url.URL) (analysisId string, err error) <span class="cov8" title="1">{
        analysis := model.WebAnalyzer{
                URL:    baseURL.String(),
                Status: StatusPending,
        }

        analysisId, err = s.repo.Save(analysis)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Error("Failed to save initial analysis: " + err.Error())
                return "", apperror.BadRequest("Failed to save initial analysis data")
        }</span>

        // Call background analysis
        <span class="cov8" title="1">go s.processAnalysisJob(context.Background(), analysisId, baseURL)

        return analysisId, nil</span>
}

func (s *webAnalyzerService) GetAnalyzeData(ctx context.Context, analyzeId string) (*contract.WebAnalyzeResponse, error) <span class="cov8" title="1">{
        result, err := s.repo.GetById(analyzeId)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Error("Failed to get analysis data: " + err.Error())
                return nil, apperror.InternalServerError("Failed to get analysis data")
        }</span>

        <span class="cov8" title="1">if result == nil </span><span class="cov8" title="1">{
                s.log.Warn("Analysis result not found")
                return nil, apperror.NotFound("Analysis result not found")
        }</span>

        <span class="cov8" title="1">var inaccessibleDetails []contract.InaccessibleLink
        if result.Links.InaccessibleDetails != nil </span><span class="cov0" title="0">{
                inaccessibleDetails = make([]contract.InaccessibleLink, len(result.Links.InaccessibleDetails))
                for i, detail := range result.Links.InaccessibleDetails </span><span class="cov0" title="0">{
                        inaccessibleDetails[i] = contract.InaccessibleLink{
                                URL:        detail.URL,
                                StatusCode: detail.StatusCode,
                        }
                }</span>
        }

        <span class="cov8" title="1">var errorDescription string
        if result.ErrorDescription != nil &amp;&amp; *result.ErrorDescription != "" </span><span class="cov0" title="0">{
                errorDescription = *result.ErrorDescription
        }</span>

        <span class="cov8" title="1">analysis := contract.WebAnalyzeResponse{
                URL:         result.URL,
                HTMLVersion: result.HTMLVersion,
                Title:       result.Title,
                Headings:    result.Headings,
                Links: contract.LinkAnalysis{
                        Internal:            result.Links.Internal,
                        External:            result.Links.External,
                        Inaccessible:        result.Links.Inaccessible,
                        InaccessibleDetails: inaccessibleDetails,
                },
                HasLoginForm:     result.HasLoginForm,
                Status:           result.Status,
                ErrorDescription: errorDescription,
        }

        return &amp;analysis, nil</span>
}

func (s *webAnalyzerService) UpdateAnalysisStatus(analyzeId string, status string, errorDescription string) <span class="cov8" title="1">{
        analysis, err := s.repo.GetById(analyzeId)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Error("Failed to get analysis data: " + err.Error())
                return
        }</span>

        <span class="cov8" title="1">if analysis == nil </span><span class="cov0" title="0">{
                s.log.Warn("Analysis not found for update: analyzeId - " + analyzeId)
                return
        }</span>

        <span class="cov8" title="1">analysis.Status = status

        if errorDescription != "" </span><span class="cov8" title="1">{
                analysis.ErrorDescription = &amp;errorDescription
        }</span>

        <span class="cov8" title="1">_, err = s.repo.Update(*analysis)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed to update analysis status: " + err.Error())
                return
        }</span>
}

func (s *webAnalyzerService) processAnalysisJob(ctx context.Context, analysisId string, baseURL *url.URL) <span class="cov8" title="1">{
        s.log.Info("Starting background analysis for: " + baseURL.String())
        analysis, err := s.repo.GetById(analysisId)
        if err != nil </span><span class="cov8" title="1">{
                s.log.Error("Failed to get analysis data: " + err.Error())
                s.UpdateAnalysisStatus(analysisId, StatusFailed, "Failed to get analysis data.")
                return
        }</span>

        <span class="cov0" title="0">resp, err := http.Get(baseURL.String())
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed to fetch URL: " + err.Error())
                s.UpdateAnalysisStatus(analysisId, StatusFailed, "URL cannot be accessed. URL is invalid or unreachable.")
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                s.log.Error("URL returned error status: " + strconv.Itoa(resp.StatusCode))
                s.UpdateAnalysisStatus(analysisId, StatusFailed, "URL cannot be accessed. URL is invalid or unreachable.")
                return
        }</span>

        <span class="cov0" title="0">doc, err := html.Parse(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed to parse HTML: " + err.Error())
                s.UpdateAnalysisStatus(analysisId, StatusFailed, "Failed to parse HTML content.")
                return
        }</span>

        //Start fill analysis data

        // 1. Start link analysis from the parsed HTML document
        <span class="cov0" title="0">analysis.Links = s.analyzeLinks(ctx, doc, baseURL)
        // End link analysis from the parsed HTML document

        // 2. Start metadata extraction from the parsed HTML document
        s.analyzeMetadata(doc, analysis)
        // End metadata extraction from the parsed HTML document

        analysis.Status = StatusSuccess
        //End fill analysis data

        _, err = s.repo.Update(*analysis)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("Failed to update analysis result: " + err.Error())
        }</span>
        <span class="cov0" title="0">s.log.Info("Background analysis completed for: " + baseURL.String())</span>
}

func (s *webAnalyzerService) analyzeMetadata(doc *html.Node, analysis *model.WebAnalyzer) <span class="cov0" title="0">{
        analysis.HTMLVersion = htmlhelper.GetHTMLVersion(doc)
        analysis.Title = htmlhelper.GetTitle(doc)
        analysis.Headings = htmlhelper.GetHeadingsCount(doc)
        analysis.HasLoginForm = htmlhelper.HasLoginForm(doc)
}</span>

func (s *webAnalyzerService) analyzeLinks(ctx context.Context, doc *html.Node, baseURL *url.URL) model.LinkAnalysis <span class="cov0" title="0">{
        links := htmlhelper.GetLinks(doc)

        analysis := model.LinkAnalysis{
                InaccessibleDetails: []model.InaccessibleLink{},
        }

        linksChan := make(chan string, len(links))
        resultsChan := make(chan model.LinkCheckResult, len(links))

        numWorkers := 10
        if len(links) &lt; numWorkers </span><span class="cov0" title="0">{
                numWorkers = len(links)
        }</span>

        <span class="cov0" title="0">wg := &amp;sync.WaitGroup{}
        //Start check links workers in background
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go s.linkChecker.RunWorker(ctx, linksChan, resultsChan, baseURL, wg)
        }</span>
        //End check links workers in background

        <span class="cov0" title="0">for _, link := range links </span><span class="cov0" title="0">{
                linksChan &lt;- link
        }</span>

        <span class="cov0" title="0">close(linksChan)

        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(resultsChan)
        }</span>()

        <span class="cov0" title="0">for result := range resultsChan </span><span class="cov0" title="0">{
                if !result.IsAccessible </span><span class="cov0" title="0">{
                        analysis.Inaccessible++
                        analysis.InaccessibleDetails = append(analysis.InaccessibleDetails, model.InaccessibleLink{
                                URL:        result.URL,
                                StatusCode: result.StatusCode,
                        })
                }</span>
        }

        <span class="cov0" title="0">for _, link := range links </span><span class="cov0" title="0">{
                if htmlhelper.IsInternalLink(link, baseURL) </span><span class="cov0" title="0">{
                        analysis.Internal++
                }</span> else<span class="cov0" title="0"> {
                        analysis.External++
                }</span>
        }

        <span class="cov0" title="0">return analysis</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package webanalyzer

import (
        "context"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "sync"
        "time"
        "web-analyzer-api/app/internal/core"
        "web-analyzer-api/app/internal/model"
        "web-analyzer-api/app/internal/util/logger"
)

type linkChecker struct {
        log *logger.Logger
}

func NewLinkChecker(log *logger.Logger) core.LinkChecker <span class="cov8" title="1">{
        return &amp;linkChecker{
                log: log,
        }
}</span>

func (lc *linkChecker) RunWorker(ctx context.Context, linksChan &lt;-chan string, resultsChan chan&lt;- model.LinkCheckResult, baseURL *url.URL, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()
        defer lc.log.Info("Link check worker stopped")

        client := &amp;http.Client{
                Timeout: 10 * time.Second,
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        return http.ErrUseLastResponse
                }</span>,
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case link, ok := &lt;-linksChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov8" title="1">result := lc.CheckLink(ctx, client, link, baseURL)
                        if result != nil </span><span class="cov8" title="1">{
                                select </span>{
                                case resultsChan &lt;- *result:<span class="cov8" title="1"></span>
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        return</span>
                                }
                        }
                }
        }
}

func (lc *linkChecker) CheckLink(ctx context.Context, client *http.Client, link string, baseURL *url.URL) *model.LinkCheckResult <span class="cov8" title="1">{
        if link == "" || strings.HasPrefix(link, "#") || strings.HasPrefix(link, "javascript:") || strings.HasPrefix(link, "mailto:") </span><span class="cov8" title="1">{
                lc.log.Warn("Invalid link: " + link)
                return nil
        }</span>

        <span class="cov8" title="1">absoluteURL := link
        if !strings.HasPrefix(link, "http://") &amp;&amp; !strings.HasPrefix(link, "https://") </span><span class="cov8" title="1">{
                parsedLink, err := url.Parse(link)
                if err != nil </span><span class="cov0" title="0">{
                        lc.log.Warn("Invalid link: " + link)
                        return nil
                }</span>
                <span class="cov8" title="1">absoluteURL = baseURL.ResolveReference(parsedLink).String()</span>
        }

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "HEAD", absoluteURL, nil)
        if err != nil </span><span class="cov8" title="1">{
                lc.log.Warn("Invalid link: " + link)
                return nil
        }</span>

        <span class="cov8" title="1">resp, err := client.Do(req)
        needsFallback := err != nil || (resp != nil &amp;&amp; resp.StatusCode &gt;= 400)

        if needsFallback </span><span class="cov8" title="1">{
                if resp != nil </span><span class="cov8" title="1">{
                        resp.Body.Close()
                }</span>

                <span class="cov8" title="1">lc.log.Debug("HEAD failed or returned error, trying GET: " + absoluteURL)
                req, err = http.NewRequestWithContext(ctx, "GET", absoluteURL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        lc.log.Debug("Failed to create GET request: " + err.Error())
                        return nil
                }</span>
                <span class="cov8" title="1">resp, err = client.Do(req)
                if err != nil </span><span class="cov8" title="1">{
                        lc.log.Debug("Inaccessible link (GET failed): " + absoluteURL)
                        return &amp;model.LinkCheckResult{
                                URL:          absoluteURL,
                                StatusCode:   0,
                                IsAccessible: false,
                        }
                }</span>
        }
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                lc.log.Debug("Inaccessible link: " + link + " with status code: " + strconv.Itoa(resp.StatusCode))
                return &amp;model.LinkCheckResult{
                        URL:          absoluteURL,
                        StatusCode:   resp.StatusCode,
                        IsAccessible: false,
                }
        }</span>

        <span class="cov8" title="1">lc.log.Debug("Accessible link: " + link + " with status code: " + strconv.Itoa(resp.StatusCode))
        return &amp;model.LinkCheckResult{
                URL:          absoluteURL,
                StatusCode:   resp.StatusCode,
                IsAccessible: true,
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package di

import (
        v1 "web-analyzer-api/app/internal/api/v1"
        webanalyzer "web-analyzer-api/app/internal/core/web_analyzer"
        "web-analyzer-api/app/internal/repositorysql"
        "web-analyzer-api/app/internal/util/logger"
)

type HTTPHandlers struct {
        WebAnalyzerHandler v1.WebAnalyzerHandler // Handles web analyzer requests
}

type Container struct {
        HTTPHandlers HTTPHandlers
}

func NewContainer(logger *logger.Logger) *Container <span class="cov8" title="1">{
        webAnalyzerRepo := repositorysql.NewWebAnalyzerRepo(logger)
        linkChecker := webanalyzer.NewLinkChecker(logger)
        webAnalyzerService := webanalyzer.NewWebAnalyzerService(logger, webAnalyzerRepo, linkChecker)
        webAnalyzerHandler := v1.NewWebAnalyzerHandler(logger, webAnalyzerService)
        logger.Info("Dependency injection container initialized successfully")

        return &amp;Container{
                HTTPHandlers: HTTPHandlers{
                        WebAnalyzerHandler: *webAnalyzerHandler,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package repositorysql

import (
        "errors"
        "web-analyzer-api/app/internal/model"
        "web-analyzer-api/app/internal/repository"
        "web-analyzer-api/app/internal/util/logger"

        "github.com/google/uuid"
)

type webAnalyzerRepo struct {
        log     *logger.Logger
        storage map[string]model.WebAnalyzer
}

func NewWebAnalyzerRepo(logger *logger.Logger) repository.WebAnalyzerRepository <span class="cov8" title="1">{
        return &amp;webAnalyzerRepo{
                log:     logger,
                storage: make(map[string]model.WebAnalyzer),
        }
}</span>

func (r *webAnalyzerRepo) Save(webAnalyzer model.WebAnalyzer) (string, error) <span class="cov8" title="1">{
        id := generateID()
        webAnalyzer.ID = id
        r.storage[id] = webAnalyzer
        return id, nil
}</span>

func (r *webAnalyzerRepo) GetById(id string) (*model.WebAnalyzer, error) <span class="cov8" title="1">{
        if val, ok := r.storage[id]; ok </span><span class="cov8" title="1">{
                return &amp;val, nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (r *webAnalyzerRepo) Update(webAnalyzer model.WebAnalyzer) (string, error) <span class="cov8" title="1">{
        if _, ok := r.storage[webAnalyzer.ID]; !ok </span><span class="cov8" title="1">{
                return "", errors.New("record not found")
        }</span>

        <span class="cov8" title="1">r.storage[webAnalyzer.ID] = webAnalyzer
        return webAnalyzer.ID, nil</span>
}

func generateID() string <span class="cov8" title="1">{
        id := uuid.New().String()
        return id
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package util

import (
        "web-analyzer-api/app/internal/util/logger"

        "github.com/gin-gonic/gin"
)

const errDefaultMessage = "Error while setting error in context"

func SetRequestError(c *gin.Context, err error, log *logger.Logger) <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                log.Error(errDefaultMessage, "error", "nil error provided")
                return
        }</span>
        <span class="cov8" title="1">c.Error(err)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package htmlhelper

import (
        "net/url"
        "strings"

        "golang.org/x/net/html"
)

func GetHTMLVersion(doc *html.Node) string <span class="cov8" title="1">{
        for n := doc.FirstChild; n != nil; n = n.NextSibling </span><span class="cov8" title="1">{
                if n.Type == html.DoctypeNode </span><span class="cov8" title="1">{
                        return getDocType(n)
                }</span>
        }

        <span class="cov8" title="1">return "Unknown"</span>
}

func getDocType(n *html.Node) string <span class="cov8" title="1">{
        if strings.EqualFold(n.Data, "html") &amp;&amp; len(n.Attr) == 0 </span><span class="cov8" title="1">{
                return "HTML5"
        }</span>

        <span class="cov8" title="1">for _, a := range n.Attr </span><span class="cov8" title="1">{
                val := strings.ToLower(a.Val)

                switch </span>{
                case strings.Contains(val, "xhtml"):<span class="cov8" title="1">
                        return "XHTML"</span>
                case strings.Contains(val, "html 4.01"):<span class="cov8" title="1">
                        return "HTML 4.01"</span>
                case strings.Contains(val, "html 4.0"):<span class="cov0" title="0">
                        return "HTML 4.0"</span>
                }
        }

        <span class="cov0" title="0">return "Unknown"</span>
}

func GetHeadingsCount(doc *html.Node) map[string]int <span class="cov8" title="1">{
        headings := map[string]int{
                "h1": 0,
                "h2": 0,
                "h3": 0,
                "h4": 0,
                "h5": 0,
                "h6": 0,
        }

        nodeList := []*html.Node{doc}

        for len(nodeList) &gt; 0 </span><span class="cov8" title="1">{
                n := nodeList[len(nodeList)-1]
                nodeList = nodeList[:len(nodeList)-1]

                if n.Type == html.ElementNode </span><span class="cov8" title="1">{
                        if _, ok := headings[n.Data]; ok </span><span class="cov8" title="1">{
                                headings[n.Data]++
                        }</span>
                }

                <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                        nodeList = append(nodeList, c)
                }</span>
        }

        <span class="cov8" title="1">return headings</span>
}

func IsInternalLink(link string, baseURL *url.URL) bool <span class="cov8" title="1">{
        if !strings.HasPrefix(link, "http://") &amp;&amp; !strings.HasPrefix(link, "https://") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">parsedLink, err := url.Parse(link)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return parsedLink.Host == baseURL.Host</span>
}

func isTitleElement(n *html.Node) bool <span class="cov8" title="1">{
        return n.Type == html.ElementNode &amp;&amp; n.Data == "title"
}</span>

func GetLinks(doc *html.Node) []string <span class="cov8" title="1">{
        var links []string
        latestNodes := []*html.Node{doc}

        for len(latestNodes) &gt; 0 </span><span class="cov8" title="1">{
                n := latestNodes[len(latestNodes)-1]
                latestNodes = latestNodes[:len(latestNodes)-1]

                if n.Type == html.ElementNode &amp;&amp; n.Data == "a" </span><span class="cov8" title="1">{
                        for _, attr := range n.Attr </span><span class="cov8" title="1">{
                                if attr.Key == "href" </span><span class="cov8" title="1">{
                                        links = append(links, attr.Val)
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                        latestNodes = append(latestNodes, c)
                }</span>
        }

        <span class="cov8" title="1">return links</span>
}

func GetTitle(doc *html.Node) string <span class="cov8" title="1">{
        if isTitleElement(doc) </span><span class="cov8" title="1">{
                return doc.FirstChild.Data
        }</span>

        <span class="cov8" title="1">for c := doc.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                result := GetTitle(c)
                if result != "" </span><span class="cov8" title="1">{
                        return result
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

func HasLoginForm(doc *html.Node) bool <span class="cov8" title="1">{
        hasPassword := false
        hasUserField := false

        stack := []*html.Node{doc}

        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                n := stack[len(stack)-1]
                stack = stack[:len(stack)-1]

                if n.Type == html.ElementNode &amp;&amp; n.Data == "input" </span><span class="cov8" title="1">{
                        t := getAttr(n, "type")
                        name := getAttr(n, "name")

                        switch t </span>{
                        case "password":<span class="cov8" title="1">
                                hasPassword = true</span>

                        case "text", "email":<span class="cov8" title="1">
                                hasUserField = true</span>
                        }

                        <span class="cov8" title="1">if strings.Contains(name, "user") ||
                                strings.Contains(name, "email") ||
                                strings.Contains(name, "login") </span><span class="cov8" title="1">{
                                hasUserField = true
                        }</span>
                }

                <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                        stack = append(stack, c)
                }</span>
        }

        <span class="cov8" title="1">return hasPassword &amp;&amp; hasUserField</span>
}

func getAttr(n *html.Node, key string) string <span class="cov8" title="1">{
        for _, a := range n.Attr </span><span class="cov8" title="1">{
                if a.Key == key </span><span class="cov8" title="1">{
                        return strings.ToLower(a.Val)
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package logger

import (
        "log/slog"
        "os"
        "strings"
)

type Logger struct {
        *slog.Logger
}

var defaultLogger *Logger

func Get(level string) *Logger <span class="cov8" title="1">{
        if defaultLogger == nil </span><span class="cov8" title="1">{
                logLevel := getLogLevel(level)
                h := slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{Level: logLevel})
                defaultLogger = &amp;Logger{Logger: slog.New(h)}
                slog.SetDefault(defaultLogger.Logger)
        }</span>
        <span class="cov8" title="1">return defaultLogger</span>
}

func getLogLevel(level string) slog.Level <span class="cov8" title="1">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov8" title="1">
                return slog.LevelDebug</span>
        case "info":<span class="cov8" title="1">
                return slog.LevelInfo</span>
        case "warn", "warning":<span class="cov8" title="1">
                return slog.LevelWarn</span>
        case "error":<span class="cov8" title="1">
                return slog.LevelError</span>
        default:<span class="cov8" title="1">
                return slog.LevelInfo</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package metrics

import (
        "sync"

        "github.com/prometheus/client_golang/prometheus"
)

var (
        httpRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                APILabels,
        )

        httpRequestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "Duration of HTTP requests in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                APIRequestDurationLabels,
        )

        registerDashboardOnce sync.Once
)

func RegisterAPIMetrics() <span class="cov8" title="1">{
        registerDashboardOnce.Do(func() </span><span class="cov8" title="1">{
                prometheus.MustRegister(httpRequestsTotal)
                prometheus.MustRegister(httpRequestDuration)
        }</span>)
}

func RecordHttpRequestTotal(method string, path string, status string) <span class="cov8" title="1">{
        httpRequestsTotal.WithLabelValues(method, path, status).Inc()
}</span>

func RecordHttpRequestDuration(method string, path string, duration float64) <span class="cov0" title="0">{
        httpRequestDuration.WithLabelValues(method, path).Observe(duration)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
